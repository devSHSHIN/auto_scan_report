import os
import json
import pandas as pd
from datetime import datetime
from packaging import version


# JSON 파일에서 데이터를 읽어와서 medium 또는 low 수준 취약점을 제거하는 함수
def del_ml_issues(data):

    if 'severity_cnt' in data:
        del data['severity_cnt']

    if 'deps_license' in data:
        del data['deps_license']

    deps_vuln_y = data.get("deps_vuln_y", {})
    deps_vuln_n = data.get("deps_vuln_n", {})

    # 패키지별로 취약점 데이터를 처리
    for pkg_name, vulns in list(deps_vuln_y.items()):
        # DataFrame으로 변환
        df = pd.json_normalize(vulns)

        # 'issueData.severity' 값이 "medium" 또는 "low"가 아닌 항목들만 필터링
        filtered_df = df[~df['issueData.severity'].isin(['medium', 'low'])]

        # 필터링 후 남은 데이터가 있으면 다시 리스트로 변환하여 저장
        if not filtered_df.empty:
            deps_vuln_y[pkg_name] = filtered_df.to_dict(orient="records")
        else:
            # 남은 데이터가 없으면 해당 패키지를 제거
            del deps_vuln_y[pkg_name]

    # 패키지별로 취약점 데이터를 처리
    for pkg_name, vulns in list(deps_vuln_n.items()):
        # DataFrame으로 변환
        df = pd.json_normalize(vulns)

        # 'issueData.severity' 값이 "medium" 또는 "low"가 아닌 항목들만 필터링
        filtered_df = df[~df['issueData.severity'].isin(['medium', 'low'])]

        # 필터링 후 남은 데이터가 있으면 다시 리스트로 변환하여 저장
        if not filtered_df.empty:
            deps_vuln_n[pkg_name] = filtered_df.to_dict(orient="records")
        else:
            # 남은 데이터가 없으면 해당 패키지를 제거
            del deps_vuln_n[pkg_name]
    
    output_file_path = '/Users/pc09164/auto_scan_report/data/del_ml_issues.json'
    with open(output_file_path, 'w', encoding='UTF-8') as f:
        json.dump(data, f, indent=4)

    # 처리된 데이터를 반환
    return data

################################################################################

def get_latest_fixed_version(pkg_name, issues):
    all_versions = []
    
    # 모든 이슈에서 fixInfo.fixedIn 버전들을 추출
    for issue in issues:
        fixed_in_versions = issue.get('fixInfo', {}).get('fixedIn', [])
        all_versions.extend(fixed_in_versions)
    
    if not all_versions:
        return None  # 버전 정보가 없는 경우 None 반환
    
    # 최신 버전 선택
    latest_version = max(all_versions, key=version.parse)
    
    return latest_version

################################################################################

def process_deps_vuln_y(data):
    processed_data = []
    current_date = datetime.now().strftime('%Y-%m-%d')  # 현재 날짜
    index = 1

    # deps_vuln_y에서 각 pkgName에 대해 데이터를 가공
    for pkg_name, issues in data.get('deps_vuln_y', {}).items():
        if not issues:
            continue  # 이슈가 없는 경우 건너뜀

        # 첫 번째 이슈의 데이터를 사용
        first_issue = issues[0]

        # issueData가 있는지 확인하고 기본값 설정
        issue_data = first_issue.get('issueData', {})

        # latest_version 함수 호출
        latest_version = get_latest_fixed_version(pkg_name, issues)

        # 각 항목을 리스트로 구성
        processed_row = [
            index,                                    # 인덱스 값
            None,                                     # 공백(null)
            issue_data.get('title', ''),              # issueData.title
            current_date,                             # 현재 날짜 (yyyy-mm-dd)
            None,                                     # 공백(null)
            issue_data.get('severity', ''),           # issueData.severity
            pkg_name,                                 # pkgName
            latest_version,                           # latest_version 함수 반환 값
            len(issues) - 1,                          # 해당 pkgName 리스트의 데이터 갯수 -1
            None,                                     # 공백(null)
            None,                                     # 공백(null)
            None,                                     # 공백(null)
            None,                                     # 공백(null)
        ]

        # 리스트에 추가
        processed_data.append(processed_row)
        index += 1
    
    output_file_path = '/Users/pc09164/auto_scan_report/data/to_xlsx_issues.json'
    with open(output_file_path, 'w', encoding='UTF-8') as f:
        json.dump(processed_data, f, indent=4)

    return processed_data

################################################################################

def process_deps_vuln_n(data):
    processed_data = []
    current_date = datetime.now().strftime('%Y-%m-%d')  # 현재 날짜
    index = 1

    # deps_vuln_n은 패키지 이름이 없음, 모든 이슈를 평탄화 처리
    issues = data.get('deps_vuln_n', [])
    if not issues:
        return processed_data
    
    first_issue = issues[0]  # 첫 번째 이슈만 처리
    
    latest_version = get_latest_fixed_version("deps_vuln_n", issues)
    
    # 리스트 생성
    processed_row = [
        index, None, first_issue['issueData'].get('title', ''),
        current_date, None, first_issue['issueData'].get('severity', ''),
        'deps_vuln_n', latest_version, len(issues) - 1,
        None, None, None, None
    ]
    
    processed_data.append(processed_row)
    
    return processed_data

################################################################################

def process_all_data(input_file_path):
    if not os.path.exists(input_file_path):
        raise FileNotFoundError(f"파일을 찾을 수 없습니다: {input_file_path}")
    
    # JSON 파일 로드
    with open(input_file_path, 'r', encoding='UTF-8') as f:
        data = json.load(f)

    # medium, low 이슈 삭제
    data = del_ml_issues(data)
    
    processed_data = []
    
    # deps_vuln_y 데이터 처리
    processed_data.extend(process_deps_vuln_y(data))
    
    # deps_vuln_n 데이터 처리 (평탄화 후 1개의 데이터로)
    processed_data.extend(process_deps_vuln_n(data))

    return processed_data